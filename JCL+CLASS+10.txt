1. INTRODUCTION TO JCL
2. JCL PARAMETERS
		1. JOB
		2. EXEC	--	PGM ,PROC , PARM , TIME , REGION , COND***
		3. DD 		DSN,DISP,SPACE,UNIT,VOL=SER,LRECL,RECFM,BLKSZIE
3. JCL UTILITES (PRE-CODED PGM)
4. JCL GDG CONCEPT
5. JCL PROC'S
6. JCL ABEND ->  S322 , S822..
=================================================================================
JCL CLASS 10:-
-------------------------------------------------------------------------------

UTILITY:-		1. IEFBR14		-> 1. DELETE A DATASET ,DISP=(OLD,DELETE,DELETE)
								2. CREATE A NEW EMPTY DATASET  		1. PROD RUN 1ST DAY		2. IMS PGM -GSAM -CREATED BEFORE
								 3. DUMMY JOB RUN

			2. IEBGENER		-> COPY  1 PS - PS		-> SORT UTILITY
			3. IEBCOPY		-> COPY  1 PDS - 1 PDS MEMBER			- NO EXAMPLE
			
			4. IEBCOMPR		-> PROJECT >  DATA CHANGE  3.13 
										CODE CHANGE  3.13		= INTERVIEW -> IEBCOMPR  (NO EXAMPLE)

			5. IDCAMS			1. DELETE A DATASET  + SET MAXCC=00
							2. DEFINE 	1. GDG
										2. KSDS CLUSTER (ONLINE)

			6. SORT | SYNCSORT		- MANY LOGIC

			7. PROJECT - CUSTOMIZED UTILITY		-> MATCHUP (MATCHING LOGIC)
											-> EMPTYDS (CHECK IF THE FILE IS EMPTY)


====SORT  ->  ARRAGNING OF THE RECORD IN AN ORDER (A/D)

	2 TYPES:		1. INTERNAL SORT		- COBOL PGM -> SORT STATEMENT
				2. EXTERNAL SORT		- JCL UTL	-->  SORT AND SYNCSORT

	ANY SORT METHOD;  WE NEED 3 FILES

		1. INPUT FILE -> DATA IS NOT IN SORTED ORDER
		2. OUTPUT FILE -> DATA WILL BE SORTED ORDER BASED ON KEY FILED
		3. WORK FILE  -> TEMP FILE SPACE , USED TO ARRANGE THE DATA IN A ORDER

	INPUT FILE  -->  GET THE DATA --> WORK FILE (SORT THE DATA) --> SEND THE SORTED -> OUTPUT FILE

	COBOL PGM:  	INPUT-FILE + OUTPUT FILE --> DATA DICISION FD PARA.
				WORK-FILE				DATA DIVISION.
									FILE SECTION.
									SD WORKFILE		SORT DESC
			

				PROCEDURE DIVISION.
							SORT WORK-FILE  USING INPUT-FILE  GIVING OUTPUT-FILE.

							--> U SHOULD NOT OPEN THE FILE , READ FLE , WRITE FILE , CLOSE -> SORT STATEMNT WILL DO IT.

		--> VSAM FILE -KSDS -> IT IS ALREADY SORTED , IF I WANT TO SORT WITH ANOTHER FIELDS -> SORT STATEMENT IN COBOL PGM


	SORT THRU UTILITY:  

				//IBMUSER JOB NOTUDY
				//STEP1   EXEC PGM=SORT   SYNCSORT**
				//SYSPRITN DD SYSOUT=*
				//SORTIN  -> INPUT FILE
				//SORTWK01  DD SPACE,UNIT,VOL		(NO DSN  ,NO DISP  -> DEFAULT -> DISP=(NEW,DELETE,DELETE)
				//SORTOUT	 -> OUTPUT FILE
				//SYSIN  DD *
				  SORT FIELDS=(START-POS,LENGTH,FORMAT,ORDER)
				/*

ACCT-NUM  X(05)		SORT FIELDS=(1,5,CH,A)
ACCT-BAL  9(05)		SORT FILEDS=(6,5,CH,D)
		9(05) COMP.	SORT FILEDS=(6,4,BI,A)
		9(05)COMP-3.	SORT FILEDS=(6,3,PD,A)


	SORT FILEDS=()
	SUM FIELDS=NONE		--> REMOVE THE DUPLICATE 

=================================================================================================
#JCL CLASS 08
=================================================================================

6. JCL ABEND ->  S322 , S822..

	WHEN U HAVE ANY ABEND (INTERVIEW -> PROJECT )

ANIL - HOW DO U SOLVE A SPACE ABEND - S322

	1. >> WE WIL INCREASE THE SPACE AND RERUN THE JOB..

	2. >> IN CASE OF SB37 - WE CHECK THE JOB LOG , FIND THE STEPS THAT FAILED, THAT RAN SUCCESFUL
				- CHECK THE DEPENDNCY
				- BEFORE PROVIDING THE SOLUTION - WE DO ANALYSIS FROM WHERE TO RESTART
				- MAKE REQUIRED CHANGES, RESTART , CHANGE GEN +1 00
				-- INCREASE THE SPACE - AS REQUIRED , CHECK IF SUBSC STEPS NEED TO INCREASE SPACE IF SO, DO IT
				-- RERUN THE JOB
				-- WAIT TILL THE JOB COMPLETE
				-- CLOSE THE TICKET WITH PROPOER SOLUTION STEPS..
				-- IF REPEated THEN WE GO FOR A PERMANENT FIX WITH A CHANGE TICKET.

S806 --> LOAD NOT FOUND..

	>> IN PRODUCTION  - DO U SEE LOAD NOT FOUND ABEND

		WHEN WE WANT TO ABEND OUR OWN JOB
		//STEP806  EXEC PGM=ABEND806,COND=(4,GT) -- IF ANY PREVIOUS STEPS GET ERROR -THIS STEP WILL ABOVE THE JOB

SB37 , SD37  SE37(PDS)
SB , SD --> SPACE OF THE PS FILE _--> I WIL SHOW U

--
SX22 _- >
		S122	-- JOB CANCELED
		S222	-- JOB CAENCEED
		S322	-- TIME OUT ABEND
		S522	-- SESSION EXPIRED
		S722	-- SPOOL LIMIT EXCEED 	-> TOO MANY DISPLAY IN PGM(NOT COMMON) -> UTIL - SENDING NUM OF MESSAGE
		S822	-- REGION ABEND >- REGION=0M RERUN - STORAGE TEAM HELP

S0C4	==> MANY REASON
		1. REASON VALID IN PRODUCTION
			OCCURS SUB/INDEX IS ABOVE THE LIMIT

			BUILD THE OCCURS TABLE	- OCCURS 10 TIMES.

				PERFORM VARYING  I  FROM 1 BY 1 UNTIL I > 10.			== WIL U SOC4 HERE? -> NO
				PERFORM VARING   I  FROM 1 BY 1 UNTIL  WS-END-OF-ROW = 'Y'.	== S0C4 WHEN U GET 11 RECORD AS INPUT

			WHEN U HAVE 11 RECORD AS INPUT**
				
				11TH -> VALID?		-- REMOVE THE RECORD -- RERUN THE PROCESS  (TELL SRC TEAM TO HOLD THE DATA -11 RECORD)
							-- WE WILL GO FOR CODE CHANGE -> 2-3 DAYS (CODE - TEST -REVIEW - APPROVAL)
							-- 2-3 DAYS - IF U GET ANY MORE S0C4 -> REMOVE AND RERUN 
							-- AFTER UR PROD IMPLEMENTATION ->> ASK SRC TO RE-SEND THOSE RECORD TO PROCESS..

					INVALID?	-- REMOVE AND RERUN THE PROCESS

	COMPILER -> SSRANGE , NOSSRANGE
		    S0C4	U WONT GET S0C4

	COMPILER --> DYNAM -- NODYNAM


S0C7		==> BAD DATA -> MOVE , IF , COMPUTE

	>>  WITH TOOL 		-- IN INTERVIEW 
	>>  WITHOUT TOOL  -- LET THEM ASK -. THEN WE TELL THIS ONE..
	
	S0C7 -> DUE TO BAD DATA..
	

	DATA IS IN FILE/TABLE ->  HOW DO I FIND WHICH RECORD IS CAUSING ISSUE (OUT OF 1000000 WHIC ONE IS HAVING INCORRECT DATA)

	1. WHICH STATEMENT IS GETTING THIS ABEND -COMPUTE , MOVE , IF , ..
	2. WHEN U KNOW THE STATEMENT -> U CAN SEE THE VARIABLE ON THAT STATEMNETN  (MOVE A TO B => A IS CRMINAL..)
	3. TRACE THE A SORCE OF THE DATA  ->  MOVE  X TO A.  = X IS THE CULPRINT .   READ FILE TO X.  > FILE IS SRC
	4. U CORRECT IT.. - RERUN.

USING -TOOL ABENDAID -> TOOL ITSELF WIL SHOW U THE STATEMENT
-- U NEED TO DO ANALYSIS TO TRACE THE SRC OF THE DATA
-- CORRECT THE DATA/REMOVE - RERUN.

	TOOL  (ABEND-AID , SYSDUMP , FAULT ANALYSZER..)
======================
#JCL CLASS 07
=================================================================================
HOW TO EDIT AND RERUN THE FAILED JOB**

 HOW TO EDIT THE PROC':
	PROC OVERIDING:
		WE CAN CHANGE THE PROC CODE THRU JOB ONLY.
		
		3 TYPES		1. SYMBOLIC PARAMETER
				2. DDNAME 
				3. PARAMETER OVERIDING

>> SYMBOLIC PARAMETER OVERIDE 
	
		=> SYMBOLIC PARAMETER --> DEVELOPER DEFINED PARAMETER

			1. PRIMARY QTY  - SECONDARY QTY
			2. GEN	NUMBER
			3. HIGHER QULIFER DATASET NAME
			4. CONTROL CARD	
		-= THESE ARE REPRESENTED BY  '&' 

		==> SYMBOLIC PARAMETER OVERIDING
			
			//STEPX  EXEC PROCNAME,PQ=05,SQ=05


2. DDNAME OVERIDING:
	
	HOW TO EDIT THE PROD DATASET

		1. COPY THE DATA INTO PERSONAL DATASET
		2. EDIT THE DATA IN PERSONAL COPY
		3. COMPARE THE UPDATES WITH  PROD 
		4. USE THE DDNAME OVERIDE TO UPDATE INPUT FILE IN THE PROC
			FROM THE JOB
			//STEPNAME.DDNAME  DD DSN=NEW.FILE.NAME..
		

3.. PARAMETER OVERIDING:
	
	COND , TIME , REGION , PARM --->   OVERIDE  ->  //STEPX  EXEC PROCNAME,PARAMETER.STEPNAME=NEW-VALUE



 HOW TO EDIT THE JOB**

IBMUSER.T6J.JOBLIB -> PROD LIB>>

DAILY -CERTAIN TIME MID-NIGHT -> SCEDHULER TOOL -> COPY ALL JOB'S THAT NEED TO RUN IN NEXT 24 HR WIL BE COPIED TO  IBMUSER.T6J.JOBCOPY

IBMUSER.T6J.JOBCOPY  - AT TIME OF TRIGGER - THE JOB WIL BE EXEUCTED -> SUCCES/ FAILED == WE CAN EDIT THE COPY JCL - RERUN
	IN THIS WE CAN ONLY SEE JOB CODE (NOT THE PROC)

5. JCL PROC'S

PROC (PROCEDURE)  = COLLECTION OF EXEC STEPS (1 OR MORE)

	READON -.	1. REUSEABLE CODE
			2. PROJECT STANDARD

	2 TYPES		

1. INSTREAM	-- THE EXEC STEPS ARE CODED WITHIN THE JOB , USING PROC - PEND KEYS

	//JOB J1
	//S1
	//S2
	//S3

		//JOB J1
		//PROCNAME PROC
		//S1
		//S2
		//S3
		//  PEND  (PROCEDURE END)
		//STEPX  EXEC PROC=PROCNAME	(//STEPX  EXEC PROCNAME --> DEFUATL - PROC )
		//STEPY  EXEC PROC=PRCONAME

2. CATALOG**  THE PROC DEFINATION  ARE OUTSIDE THE JOB , IN A DIFF PDS..

IBMUSER.T6.JCLIB			IBMUSER.T6.PROCLIB
//JOB J1				//PROCNAME PROC
//    JCLLIB  ORDER=IBMUSER.T6.PROCLIB  //S1
//STEPX  EXEC PROCNAME			//S2
					//S3

	JCLLIB -- USED TO PROVIDE THE LOCATION OF THE PROC.


PROC DO NOT ACCEPT SYSIN DD *	--> IN HERE WE USE A CONCEPT OF CONTROL CARD..

	CONTROL CARD:		IT IS A PDS MEMBER
				THIS CONTIANS THE PGM INPUT (SYSIN DD *)

	COMPONENT TYPE		-> PDS (MEMBER) CALLED AS??
	   COBOL			 PROGRAM
	   JCL				 JOB
	   LAYOUT			 COPYBOOK
	   MACHINE			 LOAD
	  TABLE COPYBOOK		 DCLGEN
	   SYSIN INPUT			 CONTROL CARD



>> CREATE A GEN  -> +1 , +2 , +3
>> WITH IN THE SAME JOB -> IF I WANT TO READ GEN CREATED IN ABOVE STEP -> +1 ,+2 , +3
>> IF I NEED TO READ ANY EXISTING ->   00 , -1 ,-2
	
	GDG BSE -> G0001V00
	JOB -> 2 GEN
			+1 , +2
	
+1  -> G0002V00	==+1
+2 --> G0003V00  -+2

	S1 ->	EXEC
			1. READ CURRENT GEN		=> 00
			2. CREATE A GEN			==> +1
			3. CREATE ANOTHER GEN		-->  +2
	S2 ->   READING - LAST FUTURE GEN		--> +2
	S3 ->	AFTER	
			+3
			+4
	S4 ->

#JCL CLASS 06
=================================================================================

4. JCL GDG CONCEPT

	GDG  -- THE SYSTEM CAN GENEARATE NEW FILE NAME FOR EACH RUN  
			- DUPLICATE DATASET ISSUE
			- DATA BACKUP

	1. CREATE THE GDG BASE
		1. 3.2.V   OR 2. IDCAMS

			1. NAME	2. LIMIT	3. EMPTY/NOEMPTY	4. SCRATCH/NOSCRATCH	5. OWNER
/* IDCAMS COMMAND */            
   DEFINE GENERATIONDATAGROUP - 
   (NAME(IBMUSER.T6.BASE) -     
    LIMIT(003) -                
    OWNER(IBMUSER) -            
    FOR(2) -                    
    NOEMPTY -                   
    SCRATCH -                   
   )                            



	2. CREATING THE GEN (PS FILE)
		
		//DDNAME  DD DSN=IBMUSER.T6.CLAIM.FILE,DISP=NEW
		//DDNAME  DD DSN=IBMUSER.T6.CLAIM.BASE(NN),DISP=NEW

	NN 	00  --  CURRENT GEN  (LATEST GEN)  > ONLY FOR READING
		+1  --  FUTURE GEN  (NEXT GEN )	---> CAN BE USED FOR CREATEING AND ALSO FOR READING
		-1  --  PAST GEN (PREVIOUS GEN)  -> ONLY FOR READING

JOB J1
	S1 - CREATE A GEN  	-> 	+1

JOB J2
	S1 -- READ AN EXISTING GEN	-> 	CURRENT - 00   , PREVIOUS = -1,-2,-3

JOB J3
	S1 -- CREATE A GEN			=> 	+1	,DISP=(NEW,CATLG,DELETE)
	S2 -- LIKE TO READ THE GEN OF S1	=> 	+1	,DISP=SHR
--
	IN ABOVE CASE -> S1  - RAN FINE		==> GEN +(G0004) -> SAVED -CATLG
			 S2  - ABEND
	Q: HOW DO U RERUN THE JOB FROM S2

		1. CHANGE THE GEN NUMBER FROM +1  - 00
		2. RESTART PARAMETER..


JOB J4 --> I WNAT TO READ MULTIPLE BACKUP FILES --

	//SYSUT1  DD DSN=BASE(00),DISP=SHR
	//	  DD DSN=BASE(-1)..


JOB J5 --->  I Want to read  ALL GEN AT ONCE

	//SYSUT1    DD DSN=BASE.NAME,DISP=SHR





IF JOB JX -> S1,S2,S3  S10 -> EACH STEP IS CREATING AN OUTPUT FILE
	               S10 FAILED --> 1. ALL FILE (S1-S9) - WIL BE DELETED		= WRONG
					2. ALL FILES (S1-S9) WIL BE CATALOGED		= RIGHT


JOB J4	 S1 -> CREATE A GEN		=> +1		== GEN WIL CREATED

JOB J5   S1 -> I WANT TO READ GEN OF S1-JOB J4		= 00

#JCL CLASS 05
=================================================================================

JCL UTILITIES:

IEBGENER , IEBCOPY , IEBCOMPR (3.13) :

THERE IS SIMPLE REQUEST FROM A USER -> FILE DATA PROCESS..  

	DEV-1 :							DEV-2
		//JOBNAM1  JOB
		//S1  -- TABLE -> FILEA			--- GDG
		//S2  -- TABLE -> FILEB			--- GDG
		//S3 --> SORT -> FILEA -> SF1	--> &&FILE,PASS
		//S4  -> SORT -> FILEB -> SF2	--> &&FILE,PASS
		//S5  -> PGM  --> SF1 + SF2 ==>  REPORT	== TESTED IT - SENT THE REPORT TO USER  VERIFIED DATA -> OKAY - U CAN MOVE TO PRODUCTION
							-- GDG

NOTE: FINAL OUTPUT FILE WIL BE GDG BASE ONLY
	-- IF U CAN RERUN AND CREATE SAME OUTPUT FILE -> NO GDG REQUIRED..
 

AS PART PRODUCTION -> SCHEDULE ==>  DAILY 6AM  == DEV-1 => RUN 6AM DAILY STARTING MONDAY:


MON - 1 ST DAY RUN   0>  JOB TRIGGER BY THE SCHEDULER  6AM -> JOB RAN ALL STEP FINE  --> CREATED REPORT --> USER VERIFY SAID ALL OKAY.
TUE -> 2ND 		 JOB TRIGGER		       6AM --> JCL ERROR 

		DUPLICATE DATASET NAME:  FILEA , FILEB , SF1 SF2 , REPORT

 HOW TO RESOLVE THIS DUCPLICATE ISSUE:

		1. DELETE THE FILES BEFORE THE CREATE.			--> THIS WIL RESOLVE THE DUPLICATE -> IT CREATE BACKUP MISSING
		2. FOR EACH RUN I NEED TO PROVIDE NEW FILE

 2. FOR EACH RUN I NEED TO PROVIDE NEW FILE

MON -> JOB 	->  FILEA1 , FILEB1..
TUE -> JOB	-> FILEA2 , FILEB2	--> DO U SEE ANY DUPLICATE?
					--> DO I HAVE BACKUP OF THE FILE A , B ? 


HOW TO CREATE A NEW FILE FOR EACH RUN:
	
	1. MANUALY - DAILY , EDIT THE PROD JOB AND PROVIDE NEW FILE
	2. VSAM-> GDG USING THIS THE SYSTEM ITSEFL WIL PROVIDE NEW FILE NAME FOR EACH RUN...

GDG - GENRERATION DATA GROUP..

	COLLECTION OF PS FILES..

2 POINTS		1. GDG BASE				IBMUSER.T6.CLAIM
			2. GDG GENERATION/PS FILE		IBMUSER.T6.CLAIM.G0001V00
								IBMUSER.T6.CLAIM.G0002V00

	1. CREATE A GDG BASE
				1. 3.2-V MANUAL 
				2. IDCAMS -- DEFINE GDG ->  RUN THRU A SCHDULER

		1. NAME OF THE BASE
		2. LIMIT OF GENERATION -> MAX = 255

			USER -> 1 WEEK BACKUP	=> LIMIT = 7
				1 MONTH		=>  LIMIT= 31
				1 YEAR		==? ?????
				10 YEAR		->  ??			-> AUDIT RULE
	
PROJECT -> 		4 GDG BASE
				DAILY		- 7 LIMIT	-> M-S -> G1,23457 => DAILY PROGRAM PROCESING		EMPTY	
				WEEKLY		- 5 LIMIT	-> 1-4/5 -> DAILY G1-G7 -> W-G1	--> IEBGENER COPY	EMPTY
				MONTHLY		- 12 LIMIT	=> W-G1-5	=.	M-G1 	-> IEBGENER COPY	EMPTY
				YEARLY		- 10 LIMIT	= M-G1-G12 ->	 Y-G1	-> COPY				NOEMPTY	
							-----
						  34 GEN FOR 10 YEARS OF DATA

		3. EMPTY / NOEMPTY
				EMPTY -> DELETE ALL GEN AND CREATE NEW GEN FOR THE DAY  =? DAILY GDG BASE -> DELETR G1-7 =-> G8 
				NOEMTY - DELETE ONLY OLDEST GEN AND CREATE THE NEW ONE  =>  DAILY GDG BASE -> DELETE G1 -> G2--G8
		4. SCRATCH /NOSRATCH

			SCRATCH -> SHIFT + DEL	== NOT ABLE TO RECOVER				== THIS ONE
			NOSC		= DEL	==> ABLE TO RECOVER FOR CERTAIN TIME
		

  1. DELETE THE FILES BEFORE THE JOB FILE CREATATION.

	HOW TO DELETE A DATASET:
		
		1. MANUAL => 3.4 =D	-- DAILY BEFORE 6AM I NEED TO DELETE AL PROD FILES MANUALLY?  -> NOT POSSIABLE
		2. UTILTIY THRU JOB	00>

			2 UTILES		1. IEFBR14	--> DEV-1  = > JOB J1 = S1 -IEFBR14 -DELETE FILEA,B,S1S3,R1,
											//DDNAME  DD DSN=....,DISP=(OLD,DELETE,DELETE)
											S2...  TEST - REPORT FINE - USER - PROD - DAILY 6AM
						2. IDCAMS	-- WE CAN DELETE THE DATASET
								//S1  EXEC PGM=IDCAMS
								//SYSPRINT DD SYSOUT=*
								//SYSIN DD *
								  DELETE ..
								  DELETE ..			COND CODE = 8
								  SET MAXCC=0			RESET  = 0
								/*


MON  -> 1ST RUN --> SCHEUDER -. TRIGGER THE JOB - 6AM ->   JCL ERROR  = FILEA B ,.. R1 ARE NOT EXISITING

			TO SOLVE THIS PROBLEM 	-> CREATE A EMPTY DATASET IN PRODUTION BEFOR 1ST RUN

		HOW TO CREATE AN EMPTY DATASET

			1. MANUAL	3.2-A 			= PRUDCTION , U MAY NOT HAVE ACCES TO CREATE A PROD FILE -3.2
			2. IEFBR14  => CRETAE AN EMPTY		= CREATE A1 TIME JOB -> IEFBR14 -> NEW FILE -> RUN IT THRU SCHDULER

	

ASSUME THIS IS THE SOLUTION FROM DEV-1 ->   //S1 - DELETE //S2,... CREATE FILES FOR THE DAY ==> TEST - MOVE PRODUCT - 6AM DAILY

MON  -> 6AM -> JOB -> DELETE OLD FILE (CC-8 SET =0) , S1,S2,S3.. RAN FINE - FIL1 .. CREATED -> USER VEROFD = OKAY
TUE -->  	   -> DELETE ALL FILE MON	--> NEW FILE TUE		--> 	.. USER.
TUE -->  	   -> DELETE ALL FILE MON	--> NEW FILE TUE		--> 	.. USER.
TUE -->  	   -> DELETE ALL FILE MON	--> NEW FILE TUE		--> 	.. USER.
TUE -->  	   -> DELETE ALL FILE MON	--> NEW FILE TUE		--> 	.. USER.
TUE -->  	   -> DELETE ALL FILE MON	--> NEW FILE TUE		--> 	.. USER.
SUN -->  	   -> DELETE ALL FILE SAT	--> NEW FILE TUE		--> 	.. USER.
==
MON ->  6AM JOB	--.	DELETE ALL FROM SUN	-> NEW FILE MON		-> USER --> SENT A MAIL TO US
	
	HI DEV1,
		CAN YOU PLEASE SEND ME LAST MONDAY REPORT ONE MORE TIME,SO I CAN COMPARE THE DATA
	
	THANKS
	USER.

	REPLY:
	HI USER
		SORRY , WE DO NOT HAVE ANY BACKUP
	THANKS
	DEV-1.



#JCL CLASS 04
=================================================================================
JCL UTILITIES:

	PRE-CODED PROGRAM HAVIN SINGLE FUNCTION OR MULTIPLE..

	COBOL -> WE CAN CODE ANY LOGIC THAT WE WANT - BUT - PGMS ARE ALWAYS LAYOUT DEPNENDENT..

	COPY PGM -> CLAIM-FILE -> 50 CHARACTER
		PGM-A => ENV - CLAIM-FNAME , DATA - LAYOUT - 50 CHAR --> READ - MOVE - WRITE  -> RUN JCL -> DDNAME - LRECL=50 -

	IF I WANT TO COPY ACCT FILE -> 60 CHARA - ANOTHER FILE.

JC UTIY -- THESE ARE NOT LAYOUT DEPENDENT.. - WITH SOME COMMON LOGIC

	IEBGENER -> COPY DATA FROM 1 FILE = ANOTHER

		CLAIM FILE  - 50
		ACCT FILE   - 60 CHAR

2ND =-> IF I WANT TO GET ANY COBOL PGM TO PRODUCTION..
	
COBOL		1. CODE 2. TEST  3. REVIEW 4. APPROV  5. IMP -> 6 PRODUCTION
UTIL		ARE ALREADY READY TO USE IN PRODUCTION...	
	

1. IEFBR14
2. IEBGENDER
3. IEBCOPY
4. IEBCOMPR
5. SORT /DFSORT /SYNCSORT
6. IDCAMS

1. IEFBR14  -->    USED TO CREATE AN EMPTY DATASET  AND TO DELETE AN EXISTING DATASET

		1. CREATE AN EMPTY DATASET

			1. MANUAL 	-> 3.2=A	=3.3
			2. JOB		-> COBOL-EXEC
					-> UTIL		- IEFBR14 , IEBGENER , SORT..

			WHY DO WE NEED TO CREATE EMPTY DATASET IN PROJECT??? /PRODUCTION	== MONDAY


		2. TO DELETE ANY EXISTING DATASET

			1. MANUAL	=> 3.4  =: D -DELETE
			2. JOB		=> UTIL

				IEBFR14	-->	//DDNAME  DD DSN=NAME,DISP=(OLD,DELETE,DELETE)

			WHY DO WE WANT TO DELETE A DATASET IN A JOB**				== MONDAY


	>> DISP=(NEW,CATLG,CATLG)  --> WHEN DO U WANT TO DELETE -> AT LAST STEP -> DELETE
	>> DISP=(NEW,CATLG,DELETE)  -> SAVE IT



2.  IEBGENER  --> LIKE , 3.3 => COPY FROM 1 PS  FILE  - ANOTHER PS FILE
		TO TAKE THE BACKUP OF THE DATA**

CASE-1
	//STEP1  EXEC PGM=IEBGENER		STEPLIB --- JOBLIB -- SYS-LIB (UTIL-LOAD)
	//SYSPRINT  DD SYSOUT=*
	//SYSOUT    DD SYSOUT=*
	//SYSUT1    DD DSN=INPUT.FILE.NAME,DISP=SHR
	//SYSUT2    DD DSN=OUTPUT.FILE.NAME,DISP=(NEW.. UNIT,VOL,SPACE..
	//SYSIN  DD DUMMY

CASE-2
//SYSUT1  DD DSN=INPUT.FILE.A,DISP=SHR
//SYSUT2  DD DSN=INPUT.FILE.A,DISP=SHR		== COMPRESS

CASE-3
//SYSUT1  DD DUMMY
//SYSUT2  DD DSN=EXIST.FILE.NAME,DISP=SHR	== EMPTY THE EXISTING FILE

CASE-4
//SYSUT1  DD DSN=INPUT.FILE.A,DISP=SHR
//        DD DSN=INPUT.FILE.B,DISP=SHR			DATASET CONCATINATION
//SYSUT2  DD DSN=OUTPUT.FILE.C,DISP=NEW...


3. IEBCOPY  ->  COPY PDS TO PDS -> WE DONT DO IN THE PROJECT AT ALL

4. IEBCOMPR ->  TO CPOMPARE A FILE OR PDS ..

	WE DONT USE THIS AT ALL.. COMPARE WE DO ...


DEVELOPER/MAIN -> REQUEST TO CHANGE A CODE OF LINE..

	1. PROD -> PROD-LIB (TOOL)					10 LINE		10000
	2. COPY OF THE CODE => PROD -> TO DEVL (PDS)			10 LINE		10000+UR CODE
	3. THERE U MADE THE REQUIRED CHANGES AS PER THE LOGIC
	4. REVIEW ->
			1. DID MEET FUCIOTNAL REQUIRMENT
			2. DID ALTER ANY EXISTING LOGIC		== 3.13 TO COMPARE THE CODE CHANGES

SUPT/ROLE

	ON A DAY -> JOB ABEND --> 1 RECORD IS WRONG -> PROBLEM - NOW I NEED TO REMOVE THE RECORD AND RERUN..

		>> IBMUSER.T6.CLAIM.PROD  --> SHALL I EDIT IN HERE!!
		>> COPY (3.3) IBMUSER.T6.CLAI.TEST  -> EDIT THE RECORD/CORR/RMOVE
		>> USE THIS TEST FILE AS INPUT FOR THE PROCESS..

			I NEED TO CHCK IF I MADE A CORRECTION ONLY TO THAT RECORD 

=============================================================================================

	     X(10)	   X(200)							FB=210			VB 214
	CLAIM-NUMBER, CLAIM-REJESCTION-NOTES			
	C1111111	INVALID AMOUNT							210			30 BYTES
	C2222222	INVALID DATE AND THIS CLAIM SHOULD BE IN THIS UNIT		210			60 BYTES


#JCL CLASS 03:
--------------------------------------------------------------------------------------------
JCL PARAMETERS:

DD STATMENT:

	//DDNAME  DD PARAMETER/LOCATION

	STEPLIB		- USED TO POINT THE PGM LOAD LOCATION	-- FOR A SINGLE STEP
	JOBLIB		- USED TO POINT THE PGM LOAD LOCATION	-- FOR ALL STEP IN A JOB

//JOBNAME  JOB
//JOBLIB  DD DSN=...
//STEP1 EXEC PGM=NAME
//STEPLIB  -- OPTIONAL

SUBMIT ->   STEPLIB - FOUND - EXECUTE
			NOT FOUND 	- JOBLIB  --FOUND - EXECUTE
						NOT FOUND		 -- SYSTEM DEFAULT LIB -> FOUND -EXECUTE (UTIL)
										NOT FOUND				--> ABEND =S806

	STEPLIB -- JOBLIB -- SYS-LIB -- S806

2.loadlib1 is for pgm01 and loadlib2 is for pgm02

//joblib dd dsn=loadlib1		-COME HERE - FOUND -> EXECUTE ==> PGM2 COME HERE - NOT FOUND --  SYS LIB - NOT FOUND -> 806
//step10 exec pgm=pgm01
//steplib dd dsn=loadlib2	-- NOT FOUND
.....
//step20 exec pgm=pgm02		-- NO STEPLIB 


PARAMETER OF THE DD STATEMENT:

			DSN			1. DSN=IBMUSER..  DASD FILE
						2. DSN=&&FILENAME  8 CHAR		&& - TEMP FILE	=TILL END OF THE JOB..
						3. DSN=&HQ..FILE.NAME 			&  - SYMBOLIC PARAMETER = PROC
						4. DUMMY				NOTHING - ANY OPERATION ON THAT DUMMY WIL BE SUCCESSFUL
						5. NO DSN				==> TEMP FILE		- TILL END OF THE STEP
						6. SYSOUT=*				== DATA TO DEFUALT - SPOOL
JOB J1
	S1 -> CREATE FILE F1
	S2 -> USING F1 - FILE F2

			DISP			DISP=SHR , MOD , OLD
						DISP=(NEW,CATLG,DELETE) 
						DISP=(NEW,CATLG,CATLG)
						DISP=(NEW,DELETE,DELETE)  - BY DEFAULT USED FOR TEMP FIES == (POINT 5 IN DSN)
						DISP=(NEW,PASS)  	--- TEMPFILE == DSN=POINT-=2

 OUTPUT+ NEW => NEW+DATA
 OUTPUT+SHR -> OVERIDE  
 OUTPUT+OLD -> OVERIDE  
 OUTPUT+MOD -> APPEND   

			UNIT, VOL-SER	
			SPACE		SPACE=(UNIT,(PQ,SQ),RLSE) 
								PQ= FIXED SPACE		= 1 : 1
								SQ= EXTENABLE SPACE	= 1 : 15
								RLSE --> IGNORE,LEAVE ALL UNUSED SPACE..
				SB37 -> 1. INCREASE THE SPACE RUN -- PRACTICAL WAY
				
			RECFM	==  FB - FIXED BLOCK - EACH RECORD WIL BE SAME LENGTH/SPACE
				    VB - VARYING BLOCK - EACH RECORD WIL BE DIFF LENGTH

			LRECL		FB -> LRECL = SAME AS SUM OF THE CHAR
					VB -> LRECL =  SUM OF CHAR + 4 BYTE
			
			BLKSIZE	= ZERO.

	SYSPRINT
	SYSOUT
	SYSIN

#JCL CLASS 02:
--------------------------------------------------------------------------------------------
JCL PARAMETERS:

//IBMUSERX  JOB (089098,28902),'TEST JOB',CLASS=A,MSGCLASS=A,MSGLEVEL=(1,1),
//		TIME=10,REGION=0M,PRTY=10,
//		RESTART=STEPNAME,
//		NOTIFY=&SYSUID,
//		USER=RACFID (WHICH ID IS HAVING ACCESS)
//*MAIN  SECENV=92
//*ROUTE...

JES2 - JES3
---------
EXEC STATEMENT:

//STEPNAME  EXEC PGM=NAME

	PGM ,PROC

	EXEC - WE CAN EXECUTE A SINGLE PROGRAM -> PGM
	EXEC - WE CAN EXECUTE A COLLECTION OF PGM => PROC

//STEP1  EXEC PGM=NAME		-- SINGLE PGM
//STEP1  EXEC PROC=NAME		-- COLLECTION OF STEP1..
//STEP1  EXEC  NAME	-- IN HERE BY DEFAULT IT WIL BE PROC ONLY

TIME, REGION PARAMETER => WE ALREADY SEEN ON THE JOB..

--
COND PARAMETER**  
		 --> USED TO BYPASS OR EXECUTE A STEP IN THE JOB.


	//JOB J1					SUB A JOB
	//S1 - CREATE A FILE1				SUCCESS/FAIL
	//S2 - USING THE FILE1 -> FILE2			SUCESS
	//S3 - USING FILE2 -- FILE3			FAILED
	//S4 - USING FILE3 + TABLE -> REPORT

ANY JOB WE SUBMIT WITH STEP , THOSE STEP EXECUTION MAY BE SUCESS / FAIL


WHEN A STEP EXECUTE IT MAY BE SUSCCESS OR FAILED -> FAILED -> 2 TYPES

		1. ERROR	- COND CODE >4 (8,12)					--> SYSTEM STILL TRY TO EXECUTE THE BELOW STEPS
		2. ABEND	- 2 TYPES  1. SYSTEM ABEND  - S322,SB37,S822,S0C4,S0C7  --> SYSTEM WILL STOP THE PROCESS ON THE SAME STEP
					   2. USER ABEND    - U3091,U3091,U4309


	//JOB J1					SUB A JOB
	//S1 - CREATE A FILE1				CC = 0
	//S2 - USING THE FILE1 -> FILE2			CC  = 4
	//S3 - USING FILE2 -- FILE3			CC = 8 ERROR
	//S4 - USING FILE3 + TABLE -> REPORT		== WE NEED TO BYPASS  == HOW TO BYPASS A STEP IN A JOB... COND PARAMETER


COND PARAMETER (BYPASS SYNTAX)

			COND=(RC,OP,STEPNAME)  OR  COND=(RC,OP)  < TO USE
EXECEPT 1ST STEP , FOR ALL OTHER STEP  USE  COND=(4,LT)

COND=(4,LT)

S4	S1,S2,S3

  4 < 0		= FALSE
  4 < 4		= FALSE
  4 < 8		= TRUE	-->  BYPASS
  4 < 12	= TRUE  -->  BYPASS


ABEND  --> IN CASE OF ABEND , THE JOB STEP WIL BE STOPPED FROM EXECUTION.. 

		SOME TIME WE MIGHT NEED SOME STEPS TO RUN IN  ABEND CASE AS WELLL..

COND PARAMETER - USED TO EXECUTE A STEP: (EXECUTE SYNTAX)

	COND=EVEN	  THE STEP WIL ALWAYS EXECUTE IN ANY CASE
	COND=ONLY	 THE STEP WIL EXECUTE ONLY IF ITS PREVIOUS STEP ABEND..

JOB J1				CASE-1		2		3	4	5	
	S1			FINE		ERROR		FINE	ABEND  FINE
	S2			FINE		SKIP		ERROR	SKIP   ABEND
	S3,COND=EVEN		EXEC		EXEC		EXEC	EXEC	EXEC


JOB J2				CASE-1		2		3	4	5	
	S1			FINE		ERROR		FINE	ABEND  FINE
	S2			FINE		SKIP		ERROR	SKIP   ABEND
	S3,COND=ONLY		BYPASS		BYPASS		BYPASS	BYPASS EXEC


	JOB J1
		S1
		S2
		S3 - CREATE A REPORT
		S4 - SEND IT AS A MAIL		- IMP OF USER TO START HIS DAILY WORK

	6AM START , 30MIN 6.30AM -- _. ABEND -> TICKET -. FIX - RERUN -> 40MIN -> 30MIN -. 7.30 >>  -> USER WIL KEEP WAITING FOR THE MAIL
		USER -REQUEST TO SEND A  NOTIFCATION IN CASE OF JOB ABEND..

	JOB J1
		S1
		S2
		S3 - CREATE A REPORT									S3 - ABEND
		SX ,COND=ONLY - SEND THE MAIL - JOB ABENDED , REPORT WIL BE DELAYED			SX - EXECUTE,COND=ONLY
		S4 - SEND IT AS A MAIL		- IMP OF USER TO START HIS DAILY WORK			S4 - BYPASS/STOP

	COND=(4,LT) - BYPASS
	COND=EVEN/ONLY -- EXECUTE

	
#JCL CLASS 01:
======================================================================================
JCL  - JOB CONTROL LANG

	JOB -> MEANS EXECUTION OF 1 OR MORE PGMS
		EACH PGM EXEC IS KNOW AS A STEP

JOB -> STEPS

	1. JOB STATMENT
	2. EXEC 
	3. DD
	4. NULL 

JOB STATMENTS;	USED TO TELL THE JOB NAME AND JOB EXECUTION SETUP PARAMETER..

	//JOBNAME   JOB  NOTIFY=&SYSUID

JCL PARAMETER'S:

	2 TYPES		1. POSITIONAL PARAMETERS	- THE PARAMETER VALUE IS IDENFIFED BY THE SYSTEM BY PLACE OF THE VALUE 
			2. KEY WORD PARAMETERS		- IT JCL DEFINED WORD

		ON A JOB STATMENT WE HAVE 2 POSITIONAL PARAMETERS

			1. ACCOUNTING-INFRO		== USED TO TRACK THE RESOURCE UNTILIZATION..

				//JOBNMAE  JOB (098902,98902),
				//JOBNAME  JOB 98902
				//JOBNAME  JOB (0903,2NSJS,28902),


			2. PRORAMMER DESCRIPTION:	COMMENT/DETAILS PROCESS OF THE JOB - 20 CHARACTER

				//JOBNAME  JOB (08902,09),'TEST JOB'


	KEY WORD PARAMETERS:

		1. NOTIFY=&SYSUID		> USED TO GET THE JOB COMPLETION NOTIFICATION FROM THE JES SYSTEM..
					WE DONOT USE THIS IN PROD JOB'S

		2. CLASS=A/B/1/2	- ADMIN PROVIDED VALUE (COPY -PASTE)

			USED TO ALLOCATE THE REQUIRED RESOURCE FOR A JOB TO RUN?

			1. WHICH CPU?
			2. HOW LONG - TIME LIMIT
			3. REGION SPACE
			4. PRTY
			5. OTHERS

		3. TIME & REGION
			TIME=(MM,SS) == THIS IS USED TO INCREASE THE TIME FOR A GIVE JOB

				IN MY APPLICATION 100 JOB -> CLASS=X -> CPUX , CPU TIME LMIT => 5MIN FOR EACH JOB , REGION SPACE = 3MB

				90JOB - R ABLE TO COMPLETE WITHIN 5MIN
			 	10 JOB -> WHICH NEED MORE TIME (MORE STEPS , MORE DATA)
					BUT WHEN ANY JOB EXCEED THE TIME LIMIT --> ABEND	S322 => CPU TIME OUT ABEND

				S322 - CPU TIME OUT ABEND -> SOLUTION IS TO INCRASE THE TIME AND RERUN..
				HOW MUCH TIME I NEED TO INCREASE?
					
				>> JOB ABEND -> LOG -> 

					START TIME	- ABEND-TIME
					10AM			10.10AM	=	> 10 MIN TIME LIMIT
						10 *2 -> TIME=20 => RERUN	==> 95% IT WIL BE SUCCESSFULL
				 5% WHEN IT FAIL AGAIN WITH SAME S322??

					1. SYSTEM	- IS THE SYSTEM IS SLOW  (1 MIN - 1000 RECORDS , 1 MIN = 10 RECORDS)
								TIME=1440 (24 HR) - MONITOR THE RUN TILL IT COMPLETES
						
					2. DATA		- WHAT WAS THE DATA COUNT YESTERDAY** AND WHAT COUNT INPUT U GOT TODAY

							5000(YESTERDAY) , 20000 (TODAY) --> CHECK BACK AND SEE WHY WE HAVE SO MUCH OF DATA
							5000 (YESTERDAY) , 6000 (TODAY) --> NO ISSUE
					3. PROGRAM IN THE LOOP**
					



			REGION=XM  == THIS IS USED TO INCREASE THE REGION SPACE FOR A GIVE JOB
			
				90 JOB -> R ABLE TO COMPLETE WITH 2MB SPACE. REGION
				10 JOB -> WHICH NEED MORE REGION SPACE (MORE STEP , MORE DATA)

					ANY JOB THAT NEED MORE REGION SPACE -> ITS NOT FIND IT -> ABEND ->  S822 - REGION SPACE NOT ENOUGH

				S822 -> REGION=0M  - TO TELL THE SYSTEM TO ALLOCATE THE REQUIRED REGION SPACE..

					99% IT WIL FIX THE ISSUE... 
					1% --- STORAGE SPACE IS ITSELF NOT AVAIBALE --> CONTACT THE STORAGE TEAM - THEY WIL FIX IT

		5. PRTY =>  USED TO INCREAE  THE PRTY OF THE JOB...
			
			JOB J1 -> SUB		10AM
			JOB J2 -> SUB		10AM

				WHICH JOB WIL RUN FIRST ?  -> BOTH WIL RUN IN SAME TIME -> MAINFRAME CAN EXECUTION ALL DIFF JOB AT SAME TIME

			JOB J1 -> SUB		10AM	-- FILE1 - LOCK
			JOB J2 -> SUB		10AM	-- FILE1 - LOCK

				PRTY = JOB J1 /J2 WIL GET THE RESOUECE..

			SCHEULER TOOL - TO SET THE TIME LINE , DEPENDENCY.. 
		
		6. MSGCLASS=A/2/C  -> USED TO TELL WHERE THE LOGS NEED TO BE PRINTED
		
			//SYSOUT  DD SYSOUT=*		-> SPOOL
			//SYSPRINT DD SYSOUT=*		-> SPOOL

			  SPOOL , PRINTER , TOOL 	1. ARCHIVE , 2. ABEND  3. REPORT

		MSGCLASS=X  -> SPOOL , PRINTER**		//SYSOUT  DD SYSOUT=*	DEFAULT OF MSGCLASS
		MSGCLASS=Y  -> SPOOL** , ARCHIVE TOOL		//SYSOUT  DD SYSOUT=*	- SPOOL

		JOB WITH NO MSGCLASS -->  //SYSOUT  DD SYSOUT=* --?  SPOOL??  PRINTER!!

		//IBMUSERX JOB NOTIFY=&SYSUID		= AFTER SOME TIME -> MANAGE CALL - INVOIVE TEAM -> PRINT THE LOG ON OUR PRINTER..

		7. MSGLEVEL=(STATMENT,MESSAGE)  = USED TO TELL WHAT LOGS NEED TO BE PRINTED

					USE - MSGLEVEL=(1,1) 	= BY DEFAULT AS WELL

			SUBMIT -.	SPOOL		JESMSGLG -- JOB START - END TIME
							JESJCL	 -- JOB STATEMENT
							JESYSMSG -- RUNNING JOB STEP MESSAGE
			

			STATEMENT	0	-- JOB
					1	-- JOB + EXEC + DD + PROC**	MAXIMUM
					2	-- JOB + EXEC + DD

			MESSAGE		0	-- STEP START-END TIME
					1	--- START-STOP TIME -- RUNNING ALLOCATION ,CAT,PASS.. MESSAGE	= MAXIMUM

		8. RESTART=STEPNAME

			USED TO RUN A JOB FROM A PARTICULAR STEPS..
			ANY JOB THAT IS SUBMMITED WILL RUN FROM FIRST STEPS..

	//JOB J1	1ST RUN					2ND RUN,RESTART=S3
	//S1		FINE						SKIP		
	//S2		FINE						SKIP
	//S3		FAILED/S322	FIX THE ISSUE			EXECUTE
		


//IBMUSERX JOB NOTIFY=&SYSUID

//IBMUSERX  JOB (089098,28902),'TEST JOB',CLASS=A,MSGCLASS=A,MSGLEVEL=(1,1),
//		TIME=10,REGION=0M,PRTY=10,
//		RESTART=STEPNAME,
//		NOTIFY=&SYSUID
